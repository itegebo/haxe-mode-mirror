#!/usr/bin/env python
#
# Parses documentation XML generated by HaXe compiler when called with
# -xml option. You can use it in the following way:
# 
# $ hxtags.py --xml dodumentation.xml
#
# will generate TAGS from an existing documentation.xml
#
# $ hxtags.py --hxml build.hxml
#
# will try to compile build.hxml file, appending -xml option to it
# and generate TAGS file. You should not specify both option at once.

from optparse import OptionParser
from os import path
import os
import StringIO
from xml.dom import minidom
from xml.dom.minidom import Document

parser = OptionParser()
parser.add_option(
    '-x', '--xml', dest = 'xml',
    help = '''The documentation XML file previously generated by HaXe compiler -xml option.
Note that only the nodes with `file' attribute are processed, and only nodes with non-null `line'
attribute are collected.''')

parser.add_option(
    '-b', '--hxml', dest = 'hxml',
    help = '''The HXML file to compile. This file is compiled by appending -xml option to it.
The resulting XML is later taken care of in the same way as with the --xml option.''')

parser.add_option(
    '-f', '--file', dest = 'file',
    help = '''The HaXe source file, it will be compiled passing the --haxe-args arguments
to HaXe compiler, appending -xml option.''')

parser.add_option(
    '-a', '--haxe-arguments', dest = 'arguments',
    help = '''The list of arguments to pass to HaXe compiler, ignored if --hxml or
--xml options are present.''')

parser.add_option(
    '-c', '--haxe-compier', dest = 'compiler', default = 'haxe',
    help = '''The location of HaXe compiler, \'haxe\' by default.''')

(options, args) = parser.parse_args()

def parseFunctionDef(node, buf, function = 'f'):
    signature = node.getElementsByTagName(function)[0]
    overloads = {}
    names = signature.getAttribute('a').split(':')
    for arg in signature.childNodes:
        if arg.nodeType != 1:
            continue
        overload = None
        name = arg.nodeName
        try:
            overload = overloads[name]
        except:
            overload = []
            overloads[name] = overload
        sub = None
        if arg.hasChildNodes():
            sub = parseFunctionDef(
                signature, StringIO.StringIO(), arg.nodeName) 
            sub = '(' + sub.getvalue() + ')'
        else:
            sub = signature.getElementsByTagName(
                name)[len(overload)].getAttribute('path')
        overload.append(sub)
    atstart = True
    for value in overloads.values():
        if not atstart:
            buf.write(' | ')
        else:
            atstart = False
        if len(value) > 1:
            atarg = True
            counter = 0
            for arg in value:
                if not atarg:
                    buf.write('->')
                else:
                    atarg = False
                name = names[counter]
                if not name:
                    name = '_'
                buf.write(name)
                buf.write(':')
                if arg:
                    buf.write(arg)
                else:
                    buf.write('*')
        else:
            if names[0]:
                buf.write(names[0])
                buf.write(':')
            if value[0]:
                buf.write(value[0])
            else:
                buf.write('*')
    return buf

def parseDeclaration(node, buf):
    if node.getAttribute('public') == '1':
        buf.write('public ')
    if node.getAttribute('static') == '1':
        buf.write('static ')
    if node.getAttribute('get') == 'inline':
        buf.write('inline ')
    child = None
    for c in node.childNodes:
        if c.nodeType == 1:
            if c.getAttribute('a') is None:
                buf.write('var ')
            else:
                buf.write('function ')
            break
    params = node.getAttribute('params')
    if params:
        params = params.split(':')
        buf.write('<')
        first = True
        for p in params:
            if not first:
                buf.write(',')
            else:
                first = False
            buf.write(p)
        buf.write('>')
    buf.write(node.nodeName)

def findPosAtLine(file, line, word):
    pos = 0
    line_pos = 0
    line -= 1
    while pos < line:
        line_pos = file.find('\n', line_pos) + 1
        pos += 1
    return file.find(word, line_pos)

def findPosBeforeLine(file, line, first_word, second_word):
    pos = 0
    line_pos = 0
    line -= 1
    sub = None
    second_pos = -1
    while pos < line:
        # this assumes no one writes class and the name
        # of the class on different lines and doesn't put comments
        # in between.
        sub = file[line_pos : file.find('\n', line_pos)]
        
        first_pos = sub.find(first_word)
        if first_pos > -1:
            second_pos = sub.find(second_word, first_pos + len(first_word))
            if second_pos > -1:
                # lame attempt to check for comments
                # we could do some more advanced logistics here.
                # for instance, one good way to make it more certain
                # we found what we need is if we don't find
                # quotes prior to the class / enum name, or that
                # we find package declaration... but this seems to
                # work for many cases. Worst - we just give the position
                # of the class in the comment line or a string, and
                # whoever will see that, maybe will just move the coment :/
                if (sub.find('//', 0, first_pos) < 0 and
                    not sub[first_pos + len(first_word) : second_pos].strip()):
                    break
        line_pos += len(sub) + 1
        pos += 1
    return pos, line_pos + second_pos

def parseContainerDef(node, buf, line, file):
    entity_name = node.getAttribute('path')
    entity = node.nodeName
    pos, line_pos = findPosBeforeLine(file, line, entity, entity_name)
    params = node.getAttribute('params')
    buf.write(entity)
    buf.write(' ')
    buf.write(entity_name)
    if params:
        params = params.split(':')
        buf.write('<')
        first = True
        for p in params:
            if not first:
                buf.write(',')
            else:
                first = False
            buf.write(p)
        buf.write('>')
    for s in ['\x20\x7F', pos, ',', line_pos, '\n']:
        buf.write(s)

def parseHaXeDoc(xml):
    xmldoc = minidom.parse(xml).documentElement
    tags = open('TAGS', 'w')
    # This is going to be huge :(
    file_cache = {}
    tags_chunks = {}
    for node in xmldoc.childNodes:
        if node.nodeType != 1:
            continue
        file = node.getAttribute('file')
        # We have the sources of this entity
        if file:
            entity_written = False
            for field in node.childNodes:
                if field.nodeType != 1:
                    continue
                line = field.getAttribute('line')
                # Unless we have line position, it is probably a file
                # from standard library. Ignore it, we don't want to
                # include the sources from standard library by default
                # especially so, there's no line position, so it's useless.
                if line:
                    if not file in file_cache:
                        with open(file, 'r') as hx_file:
                            file_cache[file] = hx_file.read()
                            sbuf = StringIO.StringIO()
                            for s in ['\x0C\x0A', file, ',', len(file_cache[file]), '\n']:
                                sbuf.write(s)
                            tags_chunks[file] = sbuf
                    buf = tags_chunks[file]
                    if not entity_written:
                        # This is a class / enum / typedef / interface
                        # none of these, unfortunately have position info
                        # so we'll have to figure that out on our own. We can search
                        # backwards from the line position of this line
                        # most chances are that the first time we hit
                        # 'class + ' ' + node.getAttribute('path') - that's
                        # our definition.
                        parseContainerDef(node, buf, int(line), file_cache[file])
                        entity_written = True
                    # Here we need to append to the list the position of the
                    # field declaration and we can parse the type of the field
                    # which we can then append to the field name. It is also
                    # possible to find method access modifiers here.
                    parseDeclaration(field, buf)
                    firstName = None
                    for c in field.childNodes:
                        if c.nodeType == 1:
                            firstName = c.nodeName
                            break
                    if firstName:
                        buf.write('::')
                        parseFunctionDef(field, buf, firstName)
                    for s in ['\x20\x7F', line, ',',
                              findPosAtLine(
                                  file_cache[file], int(line), field.nodeName), '\n']:
                        buf.write(s)
    # Now, write all of the chunks into TAGS file
    for chunk in tags_chunks.values():
        tags.write(chunk.getvalue())
        chunk.close()
    tags.close()
                    
if options.xml:
    parseHaXeDoc(options.xml)
